<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weapon HUD</title>

  <!-- Portals SDK -->
  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js?v=10005456"></script>

  <style>
    :root {
      --hud-w: 120px;
      --img-box-w: 280px;
      --img-box-h: 48px;
      --slot-h: calc(var(--img-box-h) + 28px);
      --text: rgba(255,255,255,0.94);
      --muted: rgba(255,255,255,0.68);
      --shadow: rgba(0,0,0,0.65);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: transparent;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
    }

    /* Position like a HUD element (top-right) */
    .hud {
      position: fixed;
      top: 18px;
      right: 18px;
      width: min(var(--hud-w), 92vw);
      display: grid;
      gap: 14px;
      pointer-events: none;
    }

    .slot {
      position: relative;
      height: var(--slot-h);
      display: grid;
      grid-template-columns: minmax(0, 1fr) 22px;
      column-gap: 6px;
      align-items: center;
      isolation: isolate;
      opacity: 0.72;
      transition: opacity 160ms ease-out;
    }

    .slot > * {
      position: relative;
      z-index: 1;
    }

    /* Active shadow fades out to the LEFT (strongest near the right edge) */
    .slot.active::before {
      content: "";
      position: absolute;
      top: -2px;
      bottom: -2px;
      right: -2px;
      left: -70px;
      background: linear-gradient(to left, rgba(0,0,0,0.38) 0%, rgba(0,0,0,0) 55%);
      border-radius: 16px;
    
      pointer-events: none;
      z-index: 0;
    }

    .slot.active {
      opacity: 1;
    }

    .main {
      display: grid;
      justify-items: end;
      align-content: center;
      row-gap: 1px;
      min-width: 0;
      overflow: visible; /* allow icon/text to extend left */
    }

    .weaponIcon {
      position: relative;
      display: block;
      justify-self: end;
      width: 100%;
      max-width: var(--img-box-w);   /* box acts as max width */
      height: var(--img-box-h);      /* box acts as max height */
      overflow: visible;
    }

    .weaponIcon img {
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);

      /* Fit INSIDE the box while keeping aspect ratio */
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
      object-position: right center;

      display: block;
      filter: drop-shadow(0 2px 10px rgba(0,0,0,0.35));
      user-select: none;
      -webkit-user-drag: none;
    }

    .weaponName {
      font-weight: 900;
      letter-spacing: 0.3px;
      font-size: 12px;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 2px 10px var(--shadow);
      text-align: right;
      white-space: nowrap;
      overflow: visible;       /* never cut */
      text-overflow: clip;
      width: max-content;      /* grow left as needed */
      max-width: none;
      justify-self: end;
      min-width: 0;
      pointer-events: none;
      transform: translateY(-4px);
    }

    .slotNum {
      justify-self: end;
      align-self: start;
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 2px 10px var(--shadow);
      transform: translateY(2px);
      user-select: none;
    }

    /* Optional debug (hidden by default to match CS look) */
    .debug {
      display: none;
      font-size: 11px;
      opacity: 0.55;
      text-align: right;
      text-shadow: 0 2px 10px var(--shadow);
    }

    @keyframes activePop {
      0% { transform: scale(1); }
      35% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    .slot.justActivated {
      animation: activePop 240ms ease-out 1;
    }
  </style>
</head>
<body>
  <div class="hud" aria-label="Weapon HUD">
    <div class="slot" id="slotPrimary">
      <div class="main">
        <div class="weaponIcon" id="iconPrimary" aria-hidden="true"></div>
        <div class="weaponName" id="namePrimary">Shotgun</div>
      </div>
      <div class="slotNum">1</div>
    </div>

    <div class="slot" id="slotSecondary">
      <div class="main">
        <div class="weaponIcon" id="iconSecondary" aria-hidden="true"></div>
        <div class="weaponName" id="nameSecondary">Pistol</div>
      </div>
      <div class="slotNum">2</div>
    </div>

    <div class="debug" id="debugText">Listening for SDK messages…</div>
  </div>

  <script>
    // Use your own images instead of SVG placeholders.
    // Put files in /img/ (example path you gave: /img/image.png)
    // Recommended filenames:
    //   /img/shotgun.png
    //   /img/sniper.png
    //   /img/machinegun.png
    //   /img/pistol.png
    //   /img/healinggun.png
    //   /img/unknown.png
    const ICONS = {
      Shotgun: "img/shotgun.png",
      Sniper: "img/sniper.png",
      MachineGun: "img/machinegun.png",
      Pistol: "img/pistol.png",
      HealingGun: "img/healinggun.png",
      Unknown: "img/image.png" // fallback (your example path)
    };

    // Optional: preload to avoid flicker
    Object.values(ICONS).forEach((url) => {
      const img = new Image();
      img.src = url;
    });

    // UI elements
    const slotPrimary = document.getElementById('slotPrimary');
    const slotSecondary = document.getElementById('slotSecondary');

    const iconPrimary = document.getElementById('iconPrimary');
    const iconSecondary = document.getElementById('iconSecondary');

    const namePrimary = document.getElementById('namePrimary');
    const nameSecondary = document.getElementById('nameSecondary');

    const debugText = document.getElementById('debugText');

    let lastActive = null;

    // Only parse these parts from the message:
    //   PrimaryWeapon="..."  SecondaryWeapon="..."  ActiveWeapon="Primary"|"Secondary"
    function parseWeaponMessage(message) {
      const str = String(message);

      // Match quoted values (your example uses quotes). Also tolerates unquoted words.
      const primaryMatch = str.match(/PrimaryWeapon *= *(?:"([^"]+)"|([^ ]+))/);
      const secondaryMatch = str.match(/SecondaryWeapon *= *(?:"([^"]+)"|([^ ]+))/);
      const activeMatch = str.match(/ActiveWeapon *= *(?:"(Primary|Secondary)"|(Primary|Secondary))/);

      if (!primaryMatch || !secondaryMatch || !activeMatch) return null;

      const primary = (primaryMatch[1] ?? primaryMatch[2] ?? "").trim();
      const secondary = (secondaryMatch[1] ?? secondaryMatch[2] ?? "").trim();
      const active = (activeMatch[1] ?? activeMatch[2] ?? "").trim();

      return { primary, secondary, active };
    }

    function normalizeWeaponName(name) {
      // Accept exact set; otherwise Unknown.
      // Also allow small variations (case-insensitive).
      const trimmed = String(name || "").trim();
      const key = Object.keys(ICONS).find(k => k.toLowerCase() === trimmed.toLowerCase());
      return key || 'Unknown';
    }

    function setSlot(slotEl, iconEl, nameEl, weaponName) {
      const normalized = normalizeWeaponName(weaponName);
      nameEl.textContent = normalized === 'Unknown' ? (weaponName || 'Unknown') : normalized;

      const src = ICONS[normalized] || ICONS.Unknown;

      // Reuse a single <img> per slot
      let img = iconEl.querySelector('img');
      if (!img) {
        img = document.createElement('img');
        img.draggable = false;
        iconEl.innerHTML = '';
        iconEl.appendChild(img);
      }

      img.alt = normalized;
      img.onerror = () => {
        img.onerror = null;
        img.src = ICONS.Unknown;
      };
      img.src = src;
    }

    function setActive(active) {
      slotPrimary.classList.toggle('active', active === 'Primary');
      slotSecondary.classList.toggle('active', active === 'Secondary');

      if (active && active !== lastActive) {
        const target = active === 'Primary' ? slotPrimary : slotSecondary;
        target.classList.remove('justActivated');
        void target.offsetWidth;
        target.classList.add('justActivated');
        clearTimeout(target._t);
        target._t = setTimeout(() => target.classList.remove('justActivated'), 320);
      }

      lastActive = active;
    }

    function applyState(state) {
      setSlot(slotPrimary, iconPrimary, namePrimary, state.primary);
      setSlot(slotSecondary, iconSecondary, nameSecondary, state.secondary);
      setActive(state.active);

      debugText.textContent = `Primary=${state.primary}  Secondary=${state.secondary}  Active=${state.active}`;
    }

    // Initialize with defaults
    applyState({ primary: 'Shotgun', secondary: 'Pistol', active: 'Primary' });

    // SDK listener (assume present)
    try {
      PortalsSdk.setMessageListener((message) => {
        console.log('PORTALS MSG:', message);

        const parsed = parseWeaponMessage(message);
        if (!parsed) {
          debugText.textContent = `Missing weapon fields in message.`;
          return;
        }

        // Only act on these fields; ignore everything else.
        applyState(parsed);
      });

      debugText.textContent = 'Listening for SDK messages…';
    } catch (e) {
      console.error(e);
      debugText.textContent = 'PortalsSdk not available.';
    }
    PortalsSdk.focusGameKeyboard();
  </script>
</body>
</html>
