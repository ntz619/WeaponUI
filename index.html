<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Weapon HUD</title>

  <!-- Portals SDK -->
  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js?v=10005456"></script>

  <style>
    :root {
      /* Main knobs */
      --ui-scale: 1;         /* scale the whole HUD */
      --hud-w: 200px;        /* HUD width (slot width) */
      --slot-h: 72px;        /* each weapon slot height */
      --slot-gap: 14px;      /* gap between slots */
      --slot-radius: 10px;

      --weapon-scale: 1.25;  /* scales weapon image inside the slot */

      /* Number position */
      --num-right: 6px;
      --num-top: 6px;
      --num-shift-x: -10px;  /* make more left = more negative */

      /* Text position */
      --label-right: 28px;   /* leave room for number column */
      --label-bottom: 6px;

      /* Colors */
      --text: rgba(255,255,255,0.94);
      --shadow: rgba(0,0,0,0.65);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: transparent;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
    }

    /* HUD container (top-right) */
    .hud {
      position: fixed;
      top: 18px;
      right: 18px;
      left: auto;

      width: var(--hud-w) !important;
      display: grid;
      gap: var(--slot-gap);

      transform: scale(var(--ui-scale));
      transform-origin: top right;
      will-change: transform;

      pointer-events: none;
    }

    /* Slot: also acts as the clipping mask */
    .slot {
      position: relative;
      width: 100%;
      height: var(--slot-h);
      overflow: hidden;
      border-radius: var(--slot-radius);

      opacity: 0.72;
      transition: opacity 160ms ease-out;
    }

    .slot.active {
      opacity: 1;
    }

    /* Active shadow (ALWAYS the same size: contained in slot) */
    .slot.active::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      z-index: 0;

      /* fades to the left, but never becomes fully transparent */
      background: linear-gradient(
        to left,
        rgba(0,0,0,0.38) 0%,
        rgba(0,0,0,0.22) 40%,
        rgba(0,0,0,0.00) 70%,
        rgba(0,0,0,0.00) 100%
      );

      box-shadow: 0 6px 12px rgba(0,0,0,0.14);
      pointer-events: none;
    }

    /* Weapon icon layer (can overlap label; clipped by slot) */
    .weaponIcon {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }

    .weaponIcon img {
      position: absolute;
      right: -10%;
      top: 75%;
      transform: translateY(-50%) scale(var(--weapon-scale));
      transform-origin: right center;

      height: 100%;
      width: auto;
      max-width: none;

      object-fit: contain;
      object-position: right center;

      display: block;
      /* keep this subtle so it doesn't change the perceived active shadow length */
      filter: drop-shadow(0 1px 4px rgba(0,0,0,0.25));
      user-select: none;
      -webkit-user-drag: none;
    }

    /* Label on top of the weapon */
    .weaponName {
      position: absolute;
      right: var(--label-right);
      bottom: var(--label-bottom);
      z-index: 3;

      font-weight: 900;
      letter-spacing: 0.3px;
      font-size: 12px;
      color: rgba(255,255,255,0.92);
      text-shadow: 0 2px 10px var(--shadow);

      white-space: nowrap;
      overflow: visible;     /* never cut */
      width: max-content;    /* can grow left */
      pointer-events: none;
    }

    /* Slot number */
    .slotNum {
      position: absolute;
      right: var(--num-right);
      top: var(--num-top);
      z-index: 4;

      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,0.95);
      text-shadow: 0 2px 10px var(--shadow);

      transform: translate(var(--num-shift-x), 0);
      user-select: none;
    }

    /* Optional debug (hidden) */
    .debug {
      display: none;
      font-size: 11px;
      opacity: 0.55;
      text-align: right;
      text-shadow: 0 2px 10px var(--shadow);
    }

    @keyframes activePop {
      0% { transform: scale(1); }
      35% { transform: scale(1.02); }
      100% { transform: scale(1); }
    }

    .slot.justActivated {
      animation: activePop 240ms ease-out 1;
    }
  </style>
</head>
<body>
  <div class="hud" aria-label="Weapon HUD">
    <div class="slot" id="slotPrimary">
      <div class="main">
        <div class="weaponIcon" id="iconPrimary" aria-hidden="true"></div>
        <div class="weaponName" id="namePrimary">Shotgun</div>
      </div>
      <div class="slotNum">1</div>
    </div>

    <div class="slot" id="slotSecondary">
      <div class="main">
        <div class="weaponIcon" id="iconSecondary" aria-hidden="true"></div>
        <div class="weaponName" id="nameSecondary">Pistol</div>
      </div>
      <div class="slotNum">2</div>
    </div>

    <div class="debug" id="debugText">Listening for SDK messages…</div>
  </div>

  <script>
    // Use your own images instead of SVG placeholders.
    // Put files in /img/ (example path you gave: /img/image.png)
    // Recommended filenames:
    //   /img/shotgun.png
    //   /img/sniper.png
    //   /img/machinegun.png
    //   /img/pistol.png
    //   /img/healinggun.png
    //   /img/unknown.png
    const ICONS = {
      Shotgun: "img/shotgun.png",
      Sniper: "img/sniper.png",
      MachineGun: "img/machinegun.png",
      Pistol: "img/pistol.png",
      HealingGun: "img/healinggun.png",
      Unknown: "img/image.png" // fallback (your example path)
    };

    // Optional: preload to avoid flicker
    Object.values(ICONS).forEach((url) => {
      const img = new Image();
      img.src = url;
    });

    // UI elements
    const slotPrimary = document.getElementById('slotPrimary');
    const slotSecondary = document.getElementById('slotSecondary');

    const iconPrimary = document.getElementById('iconPrimary');
    const iconSecondary = document.getElementById('iconSecondary');

    const namePrimary = document.getElementById('namePrimary');
    const nameSecondary = document.getElementById('nameSecondary');

    const debugText = document.getElementById('debugText');

    let lastActive = null;

    // Only parse these parts from the message:
    //   PrimaryWeapon="..."  SecondaryWeapon="..."  ActiveWeapon="Primary"|"Secondary"
    function parseWeaponMessage(message) {
      const str = String(message);

      // Match quoted values (your example uses quotes). Also tolerates unquoted words.
      const primaryMatch = str.match(/PrimaryWeapon *= *(?:"([^"]+)"|([^ ]+))/);
      const secondaryMatch = str.match(/SecondaryWeapon *= *(?:"([^"]+)"|([^ ]+))/);
      const activeMatch = str.match(/ActiveWeapon *= *(?:"(Primary|Secondary)"|(Primary|Secondary))/);

      if (!primaryMatch || !secondaryMatch || !activeMatch) return null;

      const primary = (primaryMatch[1] ?? primaryMatch[2] ?? "").trim();
      const secondary = (secondaryMatch[1] ?? secondaryMatch[2] ?? "").trim();
      const active = (activeMatch[1] ?? activeMatch[2] ?? "").trim();

      return { primary, secondary, active };
    }

    function normalizeWeaponName(name) {
      // Accept exact set; otherwise Unknown.
      // Also allow small variations (case-insensitive).
      const trimmed = String(name || "").trim();
      const key = Object.keys(ICONS).find(k => k.toLowerCase() === trimmed.toLowerCase());
      return key || 'Unknown';
    }

    function setSlot(slotEl, iconEl, nameEl, weaponName) {
      const normalized = normalizeWeaponName(weaponName);
      nameEl.textContent = normalized === 'Unknown' ? (weaponName || 'Unknown') : normalized;

      const src = ICONS[normalized] || ICONS.Unknown;

      // Reuse a single <img> per slot
      let img = iconEl.querySelector('img');
      if (!img) {
        img = document.createElement('img');
        img.draggable = false;
        iconEl.innerHTML = '';
        iconEl.appendChild(img);
      }

      img.alt = normalized;
      img.onerror = () => {
        img.onerror = null;
        img.src = ICONS.Unknown;
      };
      img.src = src;
    }

    function setActive(active) {
      slotPrimary.classList.toggle('active', active === 'Primary');
      slotSecondary.classList.toggle('active', active === 'Secondary');

      if (active && active !== lastActive) {
        const target = active === 'Primary' ? slotPrimary : slotSecondary;
        target.classList.remove('justActivated');
        void target.offsetWidth;
        target.classList.add('justActivated');
        clearTimeout(target._t);
        target._t = setTimeout(() => target.classList.remove('justActivated'), 320);
      }

      lastActive = active;
    }

    function applyState(state) {
      setSlot(slotPrimary, iconPrimary, namePrimary, state.primary);
      setSlot(slotSecondary, iconSecondary, nameSecondary, state.secondary);
      setActive(state.active);

      debugText.textContent = `Primary=${state.primary}  Secondary=${state.secondary}  Active=${state.active}`;
    }

    // Initialize with defaults
    applyState({ primary: 'Shotgun', secondary: 'Pistol', active: 'Primary' });

    // SDK listener (assume present)
    try {
      PortalsSdk.setMessageListener((message) => {
        console.log('PORTALS MSG:', message);

        const parsed = parseWeaponMessage(message);
        if (!parsed) {
          debugText.textContent = `Missing weapon fields in message.`;
          return;
        }

        // Only act on these fields; ignore everything else.
        applyState(parsed);
      });

      debugText.textContent = 'Listening for SDK messages…';
    } catch (e) {
      console.error(e);
      debugText.textContent = 'PortalsSdk not available.';
    }
    PortalsSdk.focusGameKeyboard();
  </script>
</body>
</html>
